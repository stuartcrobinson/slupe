=== START FILE: /Users/stuart/repos/slupe/proj/src/index.ts ===
#!/usr/bin/env node

import { startListener } from '../comp/listener/src/index.js';
import { loadConfig } from '../comp/config/src/index.js';
import { join } from 'path';
import { access, writeFile } from 'fs/promises';

function showHelp(): void {
  console.log(`Usage: slupe [options]

Options:
  --clipboard              Enable clipboard copy on execution
  --input_file <path>      Input file path (default: slupe_input.md)
  --output_file <path>     Output file path (default: .slupe_output.md)
  --help                   Show this help message

Config file options (slupe.yml):
  clipboard: boolean       Enable clipboard by default
  input_file: string       Default input file path
  output_file: string      Default output file path
`);
}

function showHelp(): void {
  console.log(`Usage: slupe [options]

Options:
  --clipboard              Enable clipboard copy on execution
  --input_file <path>      Input file path (default: slupe_input.md)
  --output_file <path>     Output file path (default: .slupe_output.md)
  --help                   Show this help message

Config file options (slupe.yml):
  clipboard: boolean       Enable clipboard by default
  input_file: string       Default input file path
  output_file: string      Default output file path
`);
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);

  if (args.includes('--help')) {
    showHelp();
    process.exit(0);
  }

  if (args.includes('--help')) {
    showHelp();
    process.exit(0);
  }
  
  const getArgValue = (flag: string): string | undefined => {
    const index = args.indexOf(flag);
    if (index >= 0 && index + 1 < args.length) {
      return args[index + 1];
    }
    return undefined;
  };

  const hasClipboardFlag = args.includes('--clipboard');
  const inputFileArg = getArgValue('--input_file');
  const outputFileArg = getArgValue('--output_file');

  const config = await loadConfig(process.cwd());
  const useClipboard = hasClipboardFlag || (config.clipboard ?? false);
  const inputFile = inputFileArg || config['input_file'] || 'slupe_input.md';
  const outputFile = outputFileArg || config['output_file'] || '.slupe_output.md';

  const filePath = join(process.cwd(), inputFile);

  // Create file if it doesn't exist
  try {
    await access(filePath);
  } catch {
    await writeFile(filePath, '', 'utf8');
    console.log(`Created: ${filePath}`);
  }

  console.log(`Starting listener on: ${filePath}`);
  console.log(`Clipboard: ${useClipboard ? 'enabled' : 'disabled'}`);

  const handle = await startListener({
    filePath,
    debounceMs: 500,
    outputFilename: outputFile,
    useClipboard
  });

  process.on('SIGINT', async () => {
    console.log('\nStopping...');
    await handle.stop();
    process.exit(0);
  });

  await new Promise(() => { });
}

main().catch(console.error);
=== END FILE: /Users/stuart/repos/slupe/proj/src/index.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/test/integration/entry.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, rmSync } from 'fs';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { marked } from 'marked';
import { load as loadYaml } from 'js-yaml';
import { startListener } from '../../comp/listener/src/index.js';

const casesPath = join(__dirname, '../../test-cases/integration/entry.cases.md');
const testDir = '/tmp/slupe-entry-tests';

describe('entry integration', () => {
  const tokens = marked.lexer(readFileSync(casesPath, 'utf8'));
  
  beforeEach(() => mkdir(testDir, { recursive: true }));
  afterEach(() => rmSync(testDir, { recursive: true, force: true }));
  
  let group = '';
  let test = '';
  let blocks: string[] = [];
  
  tokens.forEach(t => {
    if (t.type === 'heading' && t.depth === 2) group = t.text;
    else if (t.type === 'heading' && t.depth === 3) {
      if (test && blocks.length === 3) runTest(group, test, blocks);
      test = t.text;
      blocks = [];
    }
    else if (t.type === 'code') blocks.push(t.text);
  });
  if (test && blocks.length === 3) runTest(group, test, blocks);
  
  function runTest(groupName: string, testName: string, [config, input, expected]: string[]) {
    describe(groupName, () => {
      it(testName, async () => {
        const cfg = config.trim() ? loadYaml(config) || {} : {};
        const inputPath = join(testDir, 'input.md');
        const outputPath = join(testDir, '.output.md');
        
        // Always write a slupe.yml for consistent behavior
        const fullConfig = `version: 1
allowed-actions: [file_write, file_read, exec]
${config}`;
        await writeFile(join(testDir, 'slupe.yml'), fullConfig);
        
        // Write input
        await writeFile(inputPath, input);
        
        // Change to test dir so slupe.yml is found
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        try {
          // Run listener
          const handle = await startListener({
            filePath: inputPath,
            debounceMs: 100,
            outputFilename: '.output.md'
          });
          
          // Wait and check
          await new Promise(r => setTimeout(r, 300));
          await handle.stop();
          
          const actual = readFileSync(outputPath, 'utf8');
          expect(actual.trim()).toBe(expected.trim());
        } finally {
          process.chdir(originalCwd);
        }
      });
    });
  }
});
=== END FILE: /Users/stuart/repos/slupe/proj/test/integration/entry.test.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/orch/src/index.ts ===
import type { SlupeAction, ParseError } from '../../nesl-action-parser/src/index.js';
import { parseNeslResponse } from '../../nesl-action-parser/src/index.js';
import type { FileOpResult } from '../../fs-ops/src/index.js';
import { FsOpsExecutor } from '../../fs-ops/src/index.js';
import type { HooksConfig, HookContext } from '../../hooks/src/index.js';
import { HooksManager } from '../../hooks/src/index.js';
import { FsGuard } from '../../fs-guard/src/index.js';
import { ExecExecutor } from '../../exec/src/index.js';


import { loadConfig } from '../../config/src/index.js';
import type { SlupeConfig } from '../../config/src/index.js';
import { updateInstructions } from '../../instruct-gen/src/index.js';
import { ActionDefinitions } from '../../../src/unified-design.js';

export interface ExecutionResult {
  success: boolean;
  totalBlocks: number;
  executedActions: number;
  results: ActionResult[];
  parseErrors: ParseError[];
  fatalError?: string;
  hookErrors?: {
    before?: string[];
    after?: string[];
  };
  debug?: {
    parseDebug?: any;
  };
}

export interface ActionResult {
  seq: number;
  blockId: string;
  action: string;
  params: Record<string, any>;
  success: boolean;
  error?: string;
  data?: any;
}

export interface SlupeOptions {
  repoPath?: string;
  gitCommit?: boolean;
  hooks?: HooksConfig;
  enableHooks?: boolean;
}

export class Slupe {
  private constructor(
    private config: SlupeConfig,
    private executors: Map<string, (action: SlupeAction) => Promise<FileOpResult>>,
    private hooksManager: HooksManager | undefined,
    private repoPath: string
  ) { }

  static async create(options: SlupeOptions = {}): Promise<Slupe> {
    const repoPath = options.repoPath || process.cwd();

    // Load configuration
    const config = await loadConfig(repoPath);

    // Update instructions file if needed
    await updateInstructions(repoPath, config['allowed-actions']);

    // Initialize executors
    const executors = await Slupe.initializeExecutors(config, repoPath);

    // Initialize hooks if enabled
    let hooksManager: HooksManager | undefined;
    if (options.enableHooks !== false) {
      if (options.hooks) {
        // Use provided hooks configuration
        hooksManager = new HooksManager(options.hooks, undefined, repoPath);
      } else if (config.hooks) {
        // Use hooks from loaded config
        hooksManager = new HooksManager(config.hooks, config.vars, repoPath);
      }
    }

    return new Slupe(config, executors, hooksManager, repoPath);
  }

  /**
   * Parse and execute all NESL blocks in LLM output
   * Executes all valid actions sequentially, collecting both successes and failures
   */
  async execute(llmOutput: string): Promise<ExecutionResult> {
    const hookErrors: ExecutionResult['hookErrors'] = {};

    try {

      // Run before hooks
      if (this.hooksManager) {
        try {
          const beforeResult = await this.hooksManager.runBefore();
          if (!beforeResult.success) {
            // Before hook failure is fatal
            return {
              success: false,
              totalBlocks: 0,
              executedActions: 0,
              results: [],
              parseErrors: [],
              hookErrors: {
                before: beforeResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown before hook error']
              },
              fatalError: 'Before hooks failed - aborting execution'
            };
          }
        } catch (error) {
          return {
            success: false,
            totalBlocks: 0,
            executedActions: 0,
            results: [],
            parseErrors: [],
            fatalError: `Before hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`
          };
        }
      }

      // Parse NESL blocks
      const parseResult = await parseNeslResponse(llmOutput);

      // Debug info captured in parseResult.debug

      // Execute each valid action sequentially
      const results: ActionResult[] = [];
      let seq = 1;

      for (const action of parseResult.actions) {
        const result = await this.executeAction(action, seq++);
        results.push(result);
      }

      // Calculate execution success (before considering after hooks)
      const allActionsSucceeded = results.every(r => r.success);
      const noParseErrors = parseResult.errors.length === 0;
      const executionSuccess = allActionsSucceeded && noParseErrors;

      // Run after hooks with context
      if (this.hooksManager) {
        try {
          // Build rich context for hooks
          const modifiedFiles = new Set<string>();
          const operations: string[] = [];
          const errors: string[] = [];

          for (const result of results) {
            if (result.action.startsWith('file_') && result.params.path) {
              modifiedFiles.add(result.params.path);
            }

            operations.push(`${result.action}${result.success ? '' : ' (failed)'}`);

            if (!result.success && result.error) {
              errors.push(`${result.action}: ${result.error}`);
            }
          }

          const afterContext: HookContext = {
            success: executionSuccess,
            executedActions: results.length,
            totalBlocks: parseResult.summary.totalBlocks,
            modifiedFiles: Array.from(modifiedFiles).join(','),
            operations: operations.join(','),
            errors: errors.join('; '),
            errorCount: errors.length
          };

          const afterResult = await this.hooksManager.runAfter(afterContext);
          if (!afterResult.success) {
            // After hook failure affects overall success
            hookErrors.after = afterResult.errors?.map(e => `${e.command}: ${e.error}`) || ['Unknown after hook error'];
          }
        } catch (error) {
          // After hook unexpected errors also affect success
          hookErrors.after = [`After hooks threw unexpected error: ${error instanceof Error ? error.message : String(error)}`];
        }
      }

      return {
        success: executionSuccess && !hookErrors.after, // After hook errors affect overall success
        totalBlocks: parseResult.summary.totalBlocks,
        executedActions: results.length,
        results,
        parseErrors: parseResult.errors,
        ...(Object.keys(hookErrors).length > 0 && { hookErrors }),
        debug: {
          parseDebug: parseResult.debug
        }
      };

    } catch (error) {
      // Only truly unexpected errors should reach here
      return {
        success: false,
        totalBlocks: 0,
        executedActions: 0,
        results: [],
        parseErrors: [],
        fatalError: `Unexpected error in execute: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }



  /**
   * Initialize action executors with configuration
   */
  private static async initializeExecutors(config: SlupeConfig, repoPath: string): Promise<Map<string, (action: SlupeAction) => Promise<FileOpResult>>> {

    // Create fs-guard with config or empty object
    const fsGuardConfig = config['fs-guard'] || {};
    const fsGuard = new FsGuard(fsGuardConfig, repoPath);

    // Create executors
    const fsOps = new FsOpsExecutor(fsGuard);
    const exec = new ExecExecutor();

    // Build routing table from TypeScript definitions
    const executors = new Map<string, (action: SlupeAction) => Promise<FileOpResult>>();
    const validActions = new Set<string>();

    for (const [actionName, actionDef] of Object.entries(ActionDefinitions)) {
      validActions.add(actionName);
      const executorName = (actionDef as any).executor || Slupe.inferExecutor(actionName, actionDef);

      switch (executorName) {
        case 'fs-ops':
          executors.set(actionName, (action) => fsOps.execute(action));
          break;
        case 'exec':
          executors.set(actionName, (action) => exec.execute(action));
          break;
        // Skip unimplemented executors
        case 'context':
        case 'git':
          break;
        default:
          console.warn(`Unknown executor: ${executorName} for action: ${actionName}`);
      }
    }

    // Validate allowed-actions against actual available tools
    for (const tool of config['allowed-actions']) {
      if (!validActions.has(tool)) {
        throw new Error(`Invalid action in allowed-actions: '${tool}'. Valid actions: ${Array.from(validActions).join(', ')}`);
      }
    }

    return executors;
  }

  /**
   * Infer executor from action name/type when not explicitly defined
   * Temporary fallback until all YAML entries have executor field
   */
  private static inferExecutor(actionName: string, _actionDef: any): string | null {
    // File/dir operations go to fs-ops
    if (actionName.startsWith('file_') || actionName.startsWith('files_') ||
      actionName.startsWith('dir_') || ['ls', 'grep', 'glob'].includes(actionName)) {
      return 'fs-ops';
    }

    // Exec operations
    if (actionName === 'exec') {
      return 'exec';
    }

    // Context operations (future)
    if (actionName.startsWith('context_')) {
      return 'context';
    }

    // Git operations (future)
    if (actionName.startsWith('git_') || actionName === 'undo') {
      return 'git';
    }

    return null;
  }

  /**
   * Execute a single action and format the result
   * Never throws - all errors returned in ActionResult
   */
  private async executeAction(action: SlupeAction, seq: number): Promise<ActionResult> {
    if (!this.config['allowed-actions'].includes(action.action)) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Action '${action.action}' is not in allowed-actions list (${this.config['allowed-actions']})`
      };
    }

    const executor = this.executors.get(action.action);

    if (!executor) {
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }

    try {
      // Add default cwd for exec actions if not specified
      const enhancedAction = action.action === 'exec' && !action.parameters.cwd
        ? { ...action, parameters: { ...action.parameters, cwd: this.repoPath } }
        : action;

      const result = await executor(enhancedAction);

      const actionResult = {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: result.success,
        ...(result.error && { error: result.error }),
        ...(result.data !== undefined && { data: result.data }),
        // Include exec-specific fields at top level
        ...(action.action === 'exec' && {
          data: {
            stdout: (result as any).stdout,
            stderr: (result as any).stderr,
            exit_code: (result as any).exit_code,
            command: action.parameters.code
          }
        })
      };

      // Debug exec errors
      if (action.action === 'exec' && !result.success) {
        console.log('DEBUG: Exec failed in orchestrator:', result);
      }

      return actionResult;

    } catch (error) {
      // Executors should never throw, but handle just in case
      return {
        seq,
        blockId: action.metadata.blockId,
        action: action.action,
        params: action.parameters,
        success: false,
        error: `Unexpected executor error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/slupe/proj/comp/orch/src/index.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/orch/src/types.ts ===
// Re-export config types from config component
export type { SlupeConfig, FsGuardConfig } from '../../config/src/index.js';
=== END FILE: /Users/stuart/repos/slupe/proj/comp/orch/src/types.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/listener/src/formatters.ts ===
import type { ExecutionResult as OrchestratorResult } from '../../orch/src/index.js';
import { readFileSync } from 'fs';


export function formatSummary(orchResult: OrchestratorResult): string {
  const lines = ['', '=== SLUPE RESULTS ==='];

  // DEBUG: Log raw orchestrator result for parse errors
  if (orchResult.parseErrors && orchResult.parseErrors.length > 0) {
    // console.log('DEBUG: Raw parseErrors:', JSON.stringify(orchResult.parseErrors, null, 2));
  }

  // Handle hook errors first
  if (orchResult.hookErrors?.before) {
    for (const error of orchResult.hookErrors.before) {
      // Extract hook command from error message
      // Format is "command: error message"
      const match = error.match(/^(.+?):\s*(.+)$/);
      if (match) {
        const [, cmd, errorMsg] = match;
        // Check if errorMsg contains "exit code"
        if (errorMsg.includes('exit code')) {
          lines.push(`def ❌ -          ERROR: Hook '${cmd}' failed with ${errorMsg}`);
        } else {
          lines.push(`def ❌ -          ERROR: Hook '${cmd}' failed: ${errorMsg}`);
        }
      } else {
        lines.push(`def ❌ -          ERROR: ${error}`);
      }
    }
  }

  // Add execution results
  if (orchResult.results) {
    for (const result of orchResult.results) {
      const icon = result.success ? '✅' : '❌';
      const primaryParam = getPrimaryParamFromResult(result);

      if (result.success) {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam}`.trim());
      } else {
        // Debug log for exec failures
        if (result.action === 'exec' && !result.error) {
          console.log('DEBUG: Exec failed but no error field:', JSON.stringify(result, null, 2));
        }
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam} - ${getErrorSummary(result.error, result)}`.trim());
      }
    }
  }

  // Add parse errors - group by blockId
  if (orchResult.parseErrors) {
    const errorsByBlock = new Map<string, any[]>();

    // Group errors by blockId
    for (const error of orchResult.parseErrors) {
      const blockId = error.blockId || 'unknown';
      if (!errorsByBlock.has(blockId)) {
        errorsByBlock.set(blockId, []);
      }
      errorsByBlock.get(blockId)!.push(error);
    }

    // Format grouped errors
    for (const [blockId, errors] of errorsByBlock) {
      const firstError = errors[0];
      const action = firstError.action || '-';
      const lineInfo = firstError.blockStartLine ? ` (line ${firstError.blockStartLine})` : '';

      // Pad action to 10 characters for alignment
      const paddedAction = action.padEnd(10);

      if (errors.length === 1) {
        // Single error
        lines.push(`${blockId} ❌ ${paddedAction} ERROR: ${firstError.message}${lineInfo}`);
      } else {
        // Multiple errors - count unique messages
        const messageCount = new Map<string, number>();
        for (const error of errors) {
          const msg = error.message;
          messageCount.set(msg, (messageCount.get(msg) || 0) + 1);
        }

        // First line shows total count
        lines.push(`${blockId} ❌ ${paddedAction} ERROR: ${errors.length} syntax errors${lineInfo}`);

        // Sub-bullets for each unique error type
        const indent = ' '.repeat(20); // Align with ERROR: column
        for (const [msg, count] of messageCount) {
          if (count > 1) {
            lines.push(`${indent}- ${msg} (${count} occurrences)`);
          } else {
            lines.push(`${indent}- ${msg}`);
          }
        }
      }
    }
  }

  lines.push('=== END ===', '');
  return lines.join('\n');
}

function getPrimaryParamFromResult(result: any): string {
  if (!result.params) return '';
  if (result.params.path) return result.params.path;
  if (result.params.paths) {
    const paths = result.params.paths.trim().split('\n').filter((p: string) => p.trim());
    return `(${paths.length} files)`;
  }
  if (result.params.pattern) return result.params.pattern;
  if (result.params.lang) return result.params.lang;
  if (result.params.old_path) return result.params.old_path;
  return '';
}

function getErrorSummary(error?: string, result?: any): string {
  // Special handling for exec failures
  if (result?.action === 'exec' && result?.data?.stderr) {
    const stderr = result.data.stderr.trim();
    const lines = stderr.split('\n').filter((l: string) => l.trim());
    if (lines.length > 0) {
      // Get last non-empty line as likely error message
      return lines[lines.length - 1];
    }
    if (result.data.exit_code !== undefined) {
      return `Exit code ${result.data.exit_code}`;
    }
  }

  if (!error) return 'Unknown error';

  // Handle non-string errors
  if (typeof error !== 'string') {
    return 'Unknown error (non-string)';
  }

  // Extract key error info
  if (error.includes('File not found')) return 'File not found';
  if (error.includes('no such file or directory')) return 'File not found';
  if (error.includes('Permission denied')) return 'Permission denied';
  if (error.includes('Output too large')) return error; // Keep full message
  if (error.includes('TIMEOUT')) return error; // Keep timeout messages
  if (error.includes('ENOENT')) return error; // Keep command not found

  // For other errors, take first part before details
  const match = error.match(/^[^:]+:\s*([^'(]+)/);
  if (match) return match[1]!.trim();

  return error?.split('\n')[0] || 'Unknown error'; // First line only
}

/**
 * Format file read output in a human-readable way
 */
function formatFileReadOutput(result: any): string[] {
  const lines: string[] = [];

  if (result.action === 'file_read') {
    // Simple file read - data contains { path, content }
    const path = result.data.path || result.params?.path || 'unknown';
    lines.push(`=== START FILE: ${path} ===`);
    lines.push((result.data.content !== undefined ? result.data.content : result.data) || '[empty file]');
    lines.push(`=== END FILE: ${path} ===`);
  } else if (result.action === 'file_read_numbered') {
    // Numbered file read - data contains { path, content } where content has line numbers
    const path = result.data.path || result.params?.path || 'unknown';
    lines.push(`=== START FILE: [numbered] ${path} ===`);
    lines.push((result.data.content !== undefined ? result.data.content : result.data) || '[empty file]');
    lines.push(`=== END FILE: [numbered] ${path} ===`);
  } else if (result.action === 'files_read') {
    // Multiple files read - data contains { paths: string[], content: string[] }
    // Each element in content array corresponds to the file at the same index in paths
    if (result.data.paths && result.data.content) {
      lines.push(`Reading ${result.data.paths.length} files:`);

      // List all files first
      for (const path of result.data.paths) {
        lines.push(`- ${path}`);
      }

      // Add blank line before file contents
      lines.push('');

      // Format each file's content with START/END markers
      for (let i = 0; i < result.data.paths.length; i++) {
        const path = result.data.paths[i];
        const content = result.data.content[i];

        lines.push(`=== START FILE: ${path} ===`);
        lines.push(content || '[empty file]');
        lines.push(`=== END FILE: ${path} ===`);

        // Add blank line between files (except after the last one)
        if (i < result.data.paths.length - 1) {
          lines.push('');
        }
      }
    } else {
      // Fallback for unexpected format
      lines.push(`Reading 0 files:`);
    }
  }

  return lines;
}

export function formatFullOutput(orchResult: OrchestratorResult): string {
  const lines = ['=== SLUPE RESULTS ==='];

  // Handle hook errors first
  if (orchResult.hookErrors?.before) {
    for (const error of orchResult.hookErrors.before) {
      // Extract hook command from error message
      // Format is "command: error message"
      const match = error.match(/^(.+?):\s*(.+)$/);
      if (match) {
        const [, cmd, errorMsg] = match;
        // Check if errorMsg contains "exit code"
        if (errorMsg.includes('exit code')) {
          lines.push(`def ❌ -          ERROR: Hook '${cmd}' failed with ${errorMsg}`);
        } else {
          lines.push(`def ❌ -          ERROR: Hook '${cmd}' failed: ${errorMsg}`);
        }
      } else {
        lines.push(`def ❌ -          ERROR: ${error}`);
      }
    }
  }

  // Add execution results
  if (orchResult.results) {
    for (const result of orchResult.results) {
      const icon = result.success ? '✅' : '❌';
      const primaryParam = getPrimaryParamFromResult(result);

      if (result.success) {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam}`.trim());
      } else {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam} - ${getErrorSummary(result.error, result)}`.trim());
      }
    }
  }

  // Add parse errors - group by blockId
  if (orchResult.parseErrors) {
    const errorsByBlock = new Map<string, any[]>();

    // Group errors by blockId
    for (const error of orchResult.parseErrors) {
      const blockId = error.blockId || 'unknown';
      if (!errorsByBlock.has(blockId)) {
        errorsByBlock.set(blockId, []);
      }
      errorsByBlock.get(blockId)!.push(error);
    }

    // Format grouped errors
    for (const [blockId, errors] of errorsByBlock) {
      const firstError = errors[0];
      const action = firstError.action || '-';
      const lineInfo = firstError.blockStartLine ? ` (line ${firstError.blockStartLine})` : '';

      // Pad action to 10 characters for alignment
      const paddedAction = action.padEnd(10);

      if (errors.length === 1) {
        // Single error
        lines.push(`${blockId} ❌ ${paddedAction} ERROR: ${firstError.message}${lineInfo}`);
      } else {
        // Multiple errors - count unique messages
        const messageCount = new Map<string, number>();
        for (const error of errors) {
          const msg = error.message;
          messageCount.set(msg, (messageCount.get(msg) || 0) + 1);
        }

        // First line shows total count
        lines.push(`${blockId} ❌ ${paddedAction} ERROR: ${errors.length} syntax errors${lineInfo}`);

        // Sub-bullets for each unique error type
        const indent = ' '.repeat(20); // Align with ERROR: column
        for (const [msg, count] of messageCount) {
          if (count > 1) {
            lines.push(`${indent}- ${msg} (${count} occurrences)`);
          } else {
            lines.push(`${indent}- ${msg}`);
          }
        }
      }
    }
  }

  lines.push('=== END ===', '', '=== OUTPUTS ===');

  // Add outputs for successful actions based on output_display rules
  if (orchResult.results) {
    for (const result of orchResult.results) {
      // Special case: show file contents for failed text replacements
      if (!result.success &&
        ['file_replace_text', 'file_replace_all_text'].includes(result.action) &&
        result.error?.includes('not found in file') &&
        result.params?.path) {
        lines.push('', `[${result.blockId}] ${result.action} ${result.params.path} (failed - showing file contents):`);
        try {
          const content = readFileSync(result.params.path, 'utf-8');
          lines.push(`=== START FILE: ${result.params.path} ===`);
          lines.push(content);
          lines.push(`=== END FILE: ${result.params.path} ===`);
        } catch (err: any) {
          lines.push(`[Error reading file: ${err.message}]`);
        }
        continue;
      }

      if (result.data && shouldShowOutput(result.action)) {
        // Special formatting for failed exec commands
        if (result.action === 'exec' && !result.success) {
          lines.push('', `[${result.blockId}] exec ${result.params.lang || 'bash'} (failed):`);
          lines.push('command:');
          lines.push(result.data.command || result.params.code || '[command not available]');
          lines.push('');

          if (result.data.stdout) {
            lines.push('stdout:');
            lines.push(result.data.stdout.trimEnd());
            lines.push('');
          }

          if (result.data.stderr) {
            lines.push('stderr:');
            // Indent stderr content for clarity
            const stderrLines = result.data.stderr.trimEnd().split('\n');
            lines.push(...stderrLines.map((line: string) => '  ' + line));
            lines.push('');
          }

          if (result.data.exit_code !== undefined) {
            lines.push(`exit code: ${result.data.exit_code}`);
          }
          continue;
        }

        // Normal formatting for successful actions
        const primaryParam = getPrimaryParamFromResult(result);
        // For file read operations, don't include path in header since it's shown in the formatted output
        const includeParam = !['file_read', 'file_read_numbered', 'files_read'].includes(result.action);
        const header = (primaryParam && includeParam)
          ? `[${result.blockId}] ${result.action} ${primaryParam}:`
          : `[${result.blockId}] ${result.action}:`;
        lines.push('', header);

        // Special formatting for file read operations
        if (['file_read', 'file_read_numbered', 'files_read'].includes(result.action)) {
          const formattedOutput = formatFileReadOutput(result);
          lines.push(...formattedOutput);
        } else if (typeof result.data === 'string') {
          lines.push(result.data.trimEnd());
        } else if (result.data.stdout !== undefined || result.data.stderr !== undefined) {
          if (result.data.stdout) {
            lines.push(`stdout:\n${result.data.stdout.trimEnd()}`);
          }
          if (result.data.stderr) {
            lines.push(`stderr:\n${result.data.stderr.trimEnd()}`);
          }
        } else {
          lines.push(JSON.stringify(result.data, null, 2));
        }
      }
    }
  }

  lines.push('=== END ===');
  return lines.join('\n');
}

function shouldShowOutput(action: string): boolean {
  // Actions with output_display: never
  const neverShowOutput = ['file_write', 'file_replace_text', 'file_replace_all_text', 'file_append', 'file_delete', 'file_move', 'dir_create', 'dir_delete'];
  if (neverShowOutput.includes(action)) {
    return false;
  }

  // Actions with output_display: always
  const alwaysShowOutput = ['file_read', 'file_read_numbered', 'files_read', 'ls', 'grep', 'glob'];
  if (alwaysShowOutput.includes(action)) {
    return true;
  }

  // Actions with output_display: conditional
  if (action === 'exec') {
    // Always show output for debugging failed commands
    return true;
  }

  // Default to showing output for unknown actions
  return true;
}


=== END FILE: /Users/stuart/repos/slupe/proj/comp/listener/src/formatters.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/hooks/src/formatHookResult.ts ===
import type { CommandResult, HookResult } from './types.js';

/**
 * Formats array of command results into a HookResult
 * Overall success is true only if all commands succeeded
 * Collects errors from failed commands
 */
export function formatHookResult(results: CommandResult[]): HookResult {
  const errors: Array<{ command: string; error: string }> = [];
  let allSuccess = true;

  for (const result of results) {
    if (!result.success) {
      allSuccess = false;
      errors.push({
        command: result.command,
        error: result.error || 'Command failed'
      });
    }
  }

  return {
    success: allSuccess,
    executed: results.length,
    ...(errors.length > 0 && { errors })
  };
}
=== END FILE: /Users/stuart/repos/slupe/proj/comp/hooks/src/formatHookResult.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/hooks/src/index.ts ===
import { promisify } from 'util';
import { exec } from 'child_process';
import { interpolateCommand } from './interpolateCommand.js';
import { validateCommand } from './validateCommand.js';
import { formatHookResult } from './formatHookResult.js';
import type { CommandResult } from './types.js';

// Public types
export interface HooksConfig {
  version?: number;
  before?: Command[];
  after?: Command[];
  vars?: Record<string, string>;
}

export interface Command {
  run: string;
  continueOnError?: boolean;
  timeout?: number;
  cwd?: string;
}

export interface HookContext {
  [key: string]: string | number | boolean;
}

export interface HookResult {
  success: boolean;
  executed: number;
  errors?: Array<{
    command: string;
    error: string;
  }>;
}

// Promisified exec
const execAsync = promisify(exec);

// Main class
export class HooksManager {
  private config: HooksConfig;
  private vars: Record<string, string>;
  private repoPath: string;

  constructor(config?: HooksConfig, vars?: Record<string, string>, repoPath?: string) {
    this.config = config || {};
    this.vars = vars || {};
    this.repoPath = repoPath || process.cwd();
  }

  async runBefore(context?: HookContext): Promise<HookResult> {
    const commands = this.config.before || [];
    return this.runCommands(commands, context);
  }

  async runAfter(context?: HookContext): Promise<HookResult> {
    const commands = this.config.after || [];
    return this.runCommands(commands, context);
  }



  private async runCommands(commands: Command[], context?: HookContext): Promise<HookResult> {
    const results: CommandResult[] = [];

    for (const cmd of commands) {
      try {
        // Interpolate variables
        const interpolatedCmd = interpolateCommand(cmd, this.vars, context);

        // Validate command
        const validation = validateCommand(interpolatedCmd);
        if (!validation.valid) {
          const result: CommandResult = {
            command: cmd.run,
            success: false,
            error: validation.error || 'Invalid command'
          };
          results.push(result);

          if (!cmd.continueOnError) {
            break;
          }
          continue;
        }

        // Execute command
        const result = await this.executeCommand(interpolatedCmd);

        results.push({
          command: cmd.run,
          ...result
        });

        if (!result.success && !cmd.continueOnError) {
          break;
        }
      } catch (error: any) {
        const result: CommandResult = {
          command: cmd.run,
          success: false,
          error: error.message
        };
        results.push(result);

        if (!cmd.continueOnError) {
          break;
        }
      }
    }

    return formatHookResult(results);
  }

  private async executeCommand(cmd: Command): Promise<Omit<CommandResult, 'command'>> {
    const timeout = cmd.timeout || 30000;
    const options = {
      cwd: cmd.cwd || this.repoPath,
      timeout,
      encoding: 'utf8' as const,
      shell: true as any  // Ensure shell interpretation for redirects
    };

    try {
      const { stdout, stderr } = await execAsync(cmd.run, options);
      return {
        success: true,
        stdout: stdout || '',
        stderr: stderr || ''
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        stdout: error.stdout || '',
        stderr: error.stderr || ''
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/slupe/proj/comp/hooks/src/index.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/test-cases/integration/entry.cases.md ===
# Entry Point Integration Tests

## Basic Operations

### simple file write

```yaml
# config overrides (empty for defaults)
```

```sh nesl
#!nesl [@three-char-SHA-256: abc]
action = "file_write"
path = "/tmp/slupe-entry-tests/test.txt"
content = "hello world"
#!end_abc
```

```md
=== SLUPE RESULTS ===
abc ✅ file_write /tmp/slupe-entry-tests/test.txt
=== END ===

=== OUTPUTS ===
=== END ===
```

### hook failure

```yaml
hooks:
  before:
    - run: "false"  # always fails with exit code 1
```

```sh nesl
#!nesl [@three-char-SHA-256: def]
action = "file_write"
path = "/tmp/slupe-entry-tests/test2.txt"
content = "should not write"
#!end_def
```

```md
=== SLUPE RESULTS ===
def ❌ -          ERROR: Hook 'false' failed with exit code 1
=== END ===

=== OUTPUTS ===
=== END ===
```
=== END FILE: /Users/stuart/repos/slupe/proj/test-cases/integration/entry.cases.md ===

