=== START FILE: /Users/stuart/repos/slupe/proj/comp/listener/test/integration/listener-workflow-v2.test.ts ===
import { describe, it, expect, beforeAll } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { marked } from 'marked';
import { DEFAULT_SLUPE_YAML } from '../../../config/src/index.js';


import { startListener } from '../../src/listener.js';
import type { ListenerHandle } from '../../src/types.js';
// // At the top of your test file
// import { test } from 'vitest';
// test.concurrent = false;

const __dirname = dirname(fileURLToPath(import.meta.url));

interface TestCase {
  name: string;
  initialContent: string;
  newContent: string;
  expectedPrepended: string;
  expectedOutput: string;
}

// Parse test cases from markdown
async function parseTestCases(): Promise<TestCase[]> {
  const testDataPath = join(__dirname, '../../test-data/integration/listener-workflow-v2.cases.md');
  const markdown = await readFile(testDataPath, 'utf-8');

  const tokens = marked.lexer(markdown);
  const testCases: TestCase[] = [];
  let currentTest: Partial<TestCase> | null = null;
  let codeBlockCount = 0;

  for (const token of tokens) {
    // Test case name (h3)
    if (token.type === 'heading' && token.depth === 3) {
      // Save previous test if complete
      if (currentTest && currentTest.name &&
        currentTest.initialContent &&
        currentTest.newContent &&
        currentTest.expectedPrepended &&
        currentTest.expectedOutput) {
        testCases.push(currentTest as TestCase);
      }

      // Start new test
      currentTest = { name: token.text };
      codeBlockCount = 0;
    }

    // Code blocks - just take them in order, ignoring h4 headers
    if (token.type === 'code' && currentTest) {
      const content = token.text;
      codeBlockCount++;

      switch (codeBlockCount) {
        case 1:
          currentTest.initialContent = content;
          break;
        case 2:
          currentTest.newContent = content;
          break;
        case 3:
          currentTest.expectedPrepended = content;
          break;
        case 4:
          currentTest.expectedOutput = content;
          break;
      }
    }
  }

  // Don't forget the last test case
  if (currentTest && currentTest.name &&
    currentTest.initialContent &&
    currentTest.newContent &&
    currentTest.expectedPrepended &&
    currentTest.expectedOutput) {
    testCases.push(currentTest as TestCase);
  }

  return testCases;
}

// Helper to extract test directory name from test case
function getTestDir(testCaseName: string): string {
  const safeName = testCaseName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  return `/tmp/t_listener_${safeName}`;
}

// Helper to poll for file content change
async function pollForFileChange(
  filePath: string,
  initialContent: string,
  timeoutMs: number = 1000
): Promise<string> {
  const startTime = Date.now();
  let lastContent = initialContent;

  while (Date.now() - startTime < timeoutMs) {
    try {
      const content = await readFile(filePath, 'utf-8');
      if (content !== lastContent && content.includes('=== SLUPE RESULTS ===')) {
        return content;
      }
      lastContent = content;
    } catch { }
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  throw new Error(`Timeout waiting for file change after ${timeoutMs}ms`);
}

// Load test cases synchronously for parallel execution
import { readFileSync } from 'fs';
const testDataPath = join(__dirname, '../../test-data/integration/listener-workflow-v2.cases.md');
const markdown = readFileSync(testDataPath, 'utf-8');
const testCases = parseTestCasesSync(markdown);

function parseTestCasesSync(markdown: string): TestCase[] {
  const tokens = marked.lexer(markdown);
  const testCases: TestCase[] = [];
  let currentTest: Partial<TestCase> | null = null;
  let codeBlockCount = 0;

  for (const token of tokens) {
    if (token.type === 'heading' && token.depth === 3) {
      if (currentTest && currentTest.name &&
        currentTest.initialContent &&
        currentTest.newContent &&
        currentTest.expectedPrepended &&
        currentTest.expectedOutput) {
        testCases.push(currentTest as TestCase);
      }
      currentTest = { name: token.text };
      codeBlockCount = 0;
    }

    if (token.type === 'code' && currentTest) {
      const content = token.text;
      codeBlockCount++;
      switch (codeBlockCount) {
        case 1: currentTest.initialContent = content; break;
        case 2: currentTest.newContent = content; break;
        case 3: currentTest.expectedPrepended = content; break;
        case 4: currentTest.expectedOutput = content; break;
      }
    }
  }

  if (currentTest && currentTest.name &&
    currentTest.initialContent &&
    currentTest.newContent &&
    currentTest.expectedPrepended &&
    currentTest.expectedOutput) {
    testCases.push(currentTest as TestCase);
  }

  return testCases;
}

describe('listener workflow v2', () => {

  // Use it.each to create separate test for each test case
  it.concurrent.each(testCases)('$name', async (testCase) => {
    let handle: ListenerHandle | null = null;
    const testDir = getTestDir(testCase.name);
    const testFile = join(testDir, 'test.txt');
    const outputFile = join(testDir, '.slupe-output-latest.txt');

    try {
      // Setup
      await mkdir(testDir, { recursive: true });
      // Write default config to ensure test isolation
      await writeFile(join(testDir, 'slupe.yml'), DEFAULT_SLUPE_YAML);
      await writeFile(testFile, testCase.initialContent);

      // Start listener
      handle = await startListener({
        filePath: testFile,
        debounceMs: 100,
        useClipboard: false
      });

      // Wait for initial processing
      await pollForFileChange(testFile, testCase.initialContent);

      // Wait for debounce to settle
      await new Promise(resolve => setTimeout(resolve, 200));

      // Write new content
      await writeFile(testFile, testCase.newContent);

      // Wait for processing to complete
      await pollForFileChange(testFile, testCase.newContent);

      // Wait a bit more for clipboard and output file writes
      await new Promise(resolve => setTimeout(resolve, 200));

      // Read actual results
      const actualPrepended = await readFile(testFile, 'utf-8');
      const actualOutput = await readFile(outputFile, 'utf-8');

      // Compare results (exact match)
      expect(actualPrepended).toBe(testCase.expectedPrepended);
      expect(actualOutput).toBe(testCase.expectedOutput);

    } finally {
      // Cleanup
      if (handle) {
        await handle.stop();
      }
      await rm(testDir, { recursive: true, force: true });
    }
  }, 10000); // Increase timeout for integration tests
});
=== END FILE: /Users/stuart/repos/slupe/proj/comp/listener/test/integration/listener-workflow-v2.test.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/listener/src/content-processor.ts ===
import { Slupe } from '../../orch/src/index.js';
import { formatSummary, formatFullOutput } from './formatters.js';
import { computeContentHash } from './utils.js';

export interface ProcessResult {
  summary: string;
  fullOutput: string;
  hash: string;
  originalContent: string;
  executedActions?: number;
  errors?: any[];
}

export function stripSummarySection(content: string): string {
  const startMarker = '=== SLUPE RESULTS ===';
  const endMarker = '=== END ===';
  
  // Check if content starts with a SLUPE results section (with some tolerance for leading content)
  const startIndex = content.indexOf(startMarker);
  if (startIndex === -1 || startIndex > 100) {
    // No SLUPE section at the beginning of file
    return content;
  }
  
  // Find the corresponding END marker after the start
  const endIndex = content.indexOf(endMarker, startIndex);
  if (endIndex === -1) {
    return content; // Malformed section, keep content as-is
  }
  
  // Return content after the END marker, trimming leading whitespace
  return content.slice(endIndex + endMarker.length).trimStart();
}

export async function processContent(
  content: string,
  lastHash: string,
  debug?: boolean,
  repoPath?: string
): Promise<ProcessResult | null> {
  console.log('DEBUG processContent called with:', { 
    contentLength: content.length, 
    lastHash,
    contentPreview: content.substring(0, 50)
  });
  
  if (content.trim() === '') {
    console.log('DEBUG: Empty content, returning null');
    return null;
  }

  const stripped = stripSummarySection(content);
  const hash = computeContentHash(stripped.trim());

  if (hash === lastHash) {
    console.log('DEBUG: Hash unchanged, skipping processing', { hash, lastHash });
    return null;
  }

  console.log('DEBUG: Creating Slupe instance...');
  const slupe = await Slupe.create({ 
    gitCommit: false,
    repoPath 
  });
  console.log('DEBUG: Executing content...');
  const orchResult = await slupe.execute(content);
  console.log('DEBUG: Execution complete, hookErrors:', orchResult.hookErrors);

  if (debug) {
    console.log('\n=== DEBUG: Orchestrator Result ===');
    console.log('Executed actions:', orchResult.executedActions);
    console.log('Results:', orchResult.results?.length || 0);
    console.log('Parse errors:', orchResult.parseErrors?.length || 0);
    if (orchResult.parseErrors && orchResult.parseErrors.length > 0) {
      console.log('Raw parseErrors:', JSON.stringify(orchResult.parseErrors, null, 2));
    }

    if (orchResult.debug?.parseDebug) {
      const pd = orchResult.debug.parseDebug;
      console.log('\n--- Parse Debug ---');
      console.log('Input:', pd.rawInput);
      console.log('Parse result:', {
        blocks: pd.rawParseResult?.blocks?.length || 0,
        errors: pd.rawParseResult?.errors?.length || 0
      });
      if (pd.rawParseResult?.errors?.length > 0) {
        console.log('Nesl-js errors:', JSON.stringify(pd.rawParseResult.errors, null, 2));
      }
    }
    console.log('=== END DEBUG ===\n');
  }

  const summary = formatSummary(orchResult);
  const fullOutput = await formatFullOutput(orchResult);

  return {
    summary,
    fullOutput,
    hash,
    originalContent: content,
    executedActions: orchResult.executedActions,
    errors: orchResult.parseErrors
  };
}
=== END FILE: /Users/stuart/repos/slupe/proj/comp/listener/src/content-processor.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/listener/src/types.ts ===
export interface ListenerConfig {
  filePath: string;
  debounceMs?: number;
  outputFilename?: string;
  debug?: boolean;
  useClipboard?: boolean;
}

export interface ListenerHandle {
  id: string;
  filePath: string;
  stop: () => Promise<void>;
}

export interface ListenerState {
  lastExecutedHash: string;
  isProcessing: boolean;
  outputPath: string;
  inputPath: string;
  actionSchema?: Map<string, ActionDefinition>;
  debug?: boolean;
  useClipboard: boolean;
  clipboardMonitor?: {
    lastEntry: { content: string; timestamp: number } | null;
    interval: NodeJS.Timeout | null;
  };
}

export interface ActionDefinition {
  type: 'read' | 'write' | 'meta' | 'git' | 'dynamic';
  description: string;
  output_display?: 'always' | 'never' | 'conditional';
  primary_param?: string;
  parameters: Record<string, ParameterDef>;
  returns: Record<string, any>;
}

export interface ParameterDef {
  type: string;
  required: boolean;
  format?: string;
  values?: string[];
  default?: any;
}

export interface SizeCheckResult {
  valid: boolean;
  totalSize: number;
  errors: any[]; // ExecutionResult[] but avoiding circular dependency
}
=== END FILE: /Users/stuart/repos/slupe/proj/comp/listener/src/types.ts ===

=== START FILE: /Users/stuart/repos/slupe/proj/comp/orch/test/execute.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, existsSync, rmSync, mkdtempSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { tmpdir } from 'os';
import { marked, Token } from 'marked';
import { Slupe } from '../src/index.js';
import { clearActionSchemaCache } from '../../nesl-action-parser/src/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const testPath = join(__dirname, '../test-data/execute/basic-operations.md');
const mdContent = readFileSync(testPath, 'utf8');

const tokens = marked.lexer(mdContent);
const codeBlocks = tokens.filter(t => t.type === 'code') as Array<Token & { type: 'code', text: string, lang?: string }>;
const testNames = tokens
  .filter(t => t.type === 'heading' && 'depth' in t && t.depth === 3)
  .map(t => (t as any).text as string);

const testFiles = [
  '/tmp/test.txt',
  '/tmp/first.txt',
  '/tmp/second.txt',
  '/tmp/bad.txt',
  '/tmp/duplicate.txt',
  '/tmp/good.txt',
  '/tmp/does-not-exist.txt',
  '/tmp/read-test.txt',
  '/tmp/source-file.txt',
  '/tmp/destination-file.txt',
  '/tmp/replace-single.txt',
  '/tmp/replace-all.txt',
  '/tmp/multiline.txt',
  '/tmp/multiple-foo.txt',
  '/tmp/count-test.txt',
  '/tmp/move-source.txt',
  '/tmp/move-dest.txt',
  '/tmp/empty-replace.txt',
  '/tmp/parent-test.txt'
];

const testDirs = [
  '/tmp/new',
  '/tmp/007-file-move-success',
  '/tmp/016-file-move-creates-parent-dirs',
  '/tmp/017-files-read-multiple',
  '/tmp/018-files-read-with-missing'
];

describe('Slupe.execute()', () => {
  let slupe: Slupe;
  let testRepoPath: string;

  beforeEach(async () => {
    // Clear the action schema cache to pick up latest definitions
    clearActionSchemaCache();
    
    // Create isolated test directory
    testRepoPath = mkdtempSync(join(tmpdir(), 'slupe-test-'));
    
    // Create Slupe instance with isolated repo path
    slupe = await Slupe.create({ 
      repoPath: testRepoPath,
      enableHooks: false  // Explicitly disable hooks for these tests
    });
    
    // Clean up files
    for (const path of testFiles) {
      try {
        if (existsSync(path)) rmSync(path);
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up directories
    for (const path of testDirs) {
      try {
        if (existsSync(path)) rmSync(path, { recursive: true, force: true });
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
  });

  afterEach(() => {
    // Clean up files
    for (const path of testFiles) {
      try {
        if (existsSync(path)) rmSync(path);
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up directories
    for (const path of testDirs) {
      try {
        if (existsSync(path)) rmSync(path, { recursive: true, force: true });
      } catch (err) {
        // Continue cleanup even if one fails
      }
    }
    // Clean up test repo directory
    try {
      if (existsSync(testRepoPath)) {
        rmSync(testRepoPath, { recursive: true, force: true });
      }
    } catch (err) {
      // Continue cleanup even if one fails
    }
  });

  testNames.forEach((name, i) => {
    const baseIndex = i * 2;
    it(name, async () => {
      const input = codeBlocks[baseIndex].text;
      const expected = JSON.parse(codeBlocks[baseIndex + 1].text);
      const result = await slupe.execute(input);

      // Remove debug field for comparison since test data doesn't include it
      const { debug, ...resultWithoutDebug } = result;
      expect(resultWithoutDebug).toEqual(expected);
    });
  });
});
=== END FILE: /Users/stuart/repos/slupe/proj/comp/orch/test/execute.test.ts ===

