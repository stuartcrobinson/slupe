# Unit tests for target matching flexibility
# Tests various ways to specify the same target

- name: class_variations
  file: service.ts
  content: |2
    @Injectable()
    export class UserService extends BaseService {
      constructor(private db: Database) {
        super();
      }
    }
  variations:
    - target: "UserService"
      should_match: true
    - target: "export class UserService"
      should_match: true
    - target: "class UserService"
      should_match: true
    - target: "UserService {"
      should_match: true
    - target: "export class UserService {"
      should_match: true
    - target: "export class UserService extends"
      should_match: true
    - target: "@Injectable()"
      should_match: false  # Decorator alone doesn't match
    - target: "Service"
      should_match: false  # Partial name doesn't match
    - target: "BaseService"
      should_match: false  # Parent class doesn't match

- name: function_variations
  file: utils.ts
  content: |2
    export async function processData(input: string): Promise<Result> {
      return await transform(input);
    }
  variations:
    - target: "processData"
      should_match: true
    - target: "function processData"
      should_match: true
    - target: "async function processData"
      should_match: true
    - target: "export async function processData"
      should_match: true
    - target: "processData(input:"
      should_match: true
    - target: "function processData(input: string)"
      should_match: true
    - target: "process"
      should_match: false  # Partial name
    - target: "transform"
      should_match: false  # Different function

- name: method_variations
  file: class.ts
  content: |2
    class Calculator {
      public calculate(x: number): number {
        return x * 2;
      }
    }
  variations:
    - target: |
        Calculator
        calculate
      should_match: true
    - target: |
        Calculator
        public calculate
      should_match: true
    - target: |
        Calculator
        calculate(x: number)
      should_match: true
    - target: "calculate"  # Without parent
      should_match: true  # But would be ambiguous if multiple exist

- name: python_def_variations
  file: module.py
  content: |2
    @cache
    def expensive_operation(n: int) -> int:
        return sum(i * i for i in range(n))
  variations:
    - target: "expensive_operation"
      should_match: true
    - target: "def expensive_operation"
      should_match: true
    - target: "expensive_operation(n:"
      should_match: true
    - target: "@cache"
      should_match: false  # Decorator alone
    - target: "def expensive_operation(n: int) -> int:"
      should_match: true

- name: nested_target_specificity
  file: nested.ts
  content: |2
    export class OuterClass {
      innerMethod() {
        if (condition) {
          return true;
        }
      }
    }
  variations:
    - target: |
        OuterClass
        innerMethod
        if (condition)
      should_match: true
    - target: |
        OuterClass
        if (condition)
      should_match: false  # Skipped intermediate level
    - target: |
        innerMethod
        if (condition)
      should_match: true  # Valid without top-level parent