Tight follow-ups (choose now)
Verbatim allowed for parents? I propose yes (for symmetry), but advise identifier/canonical first. Agree?

Permit trailing delimiter in verbatim? I propose: optional (either with or without :/{).

Normalization scope: trim ends + collapse runs of whitespace to single spaces. Keep case-sensitive? (I’d say case-sensitive.)

Exact canonical forms list per language (JS/TS, Python, Java, etc.). Want me to draft the minimal tables?

Ambiguity UX: return TARGET_AMBIGUOUS with candidate headers to help the LLM auto-correct. OK?


----


Below are the allowed target forms I’d recommend per node, using the tight model we discussed:


Conventions - 3 differenet options

1. Identifier-only = for named declarations only.

2. Verbatim header = the node’s first line, whitespace-normalized, optionally dropping the single trailing block char ({ / :).

3. Canonical block = for control-flow blocks  (e.g., if …), optionally dropping the single trailing block char ({ / :).

Case-sensitive; no substrings.
----



---

"Truncate at first stop token" breaks common patterns:
typescript// Generic with constraint
function process<T extends Base>(item: T) { }
// Truncates at '<' → "function process"

// Multiple params
function add(a: number, b: number) { }
// Truncates at '(' → "function add"

// Same name, different arity - now ambiguous!
function add(a: number) { }
function add(a: number, b: number) { }
// Both become "function add" after truncation
You've recreated the static problem - truncating at ( collapses overloads.


---> acceptable risk.  LLM can be more specific if it needs to be.  good that our system allows reading all with 'add' target

---

Hidden complexity
"Collapse internal whitespace" isn't deterministic:
typescriptfunction  foo  <  T  >  (  x  :  T  )
Becomes what?
function foo < T > ( x : T ) (spaces around all tokens)
function foo<T>(x: T) (no spaces around punctuation)
function foo <T> (x: T) (language-specific rules)

---> ok lets just start by normalizing whitesapce so any doulbe-space is converted to single.  later we could remove all whitespace s.t. didn't change var names (at non word char boundaries etc or somethign)

----


Here’s a crisp way to describe it (for docs and for the LLM), plus guardrails so it doesn’t get sloppy.

Target format (what the LLM writes)
A target is a multi-line path. Each line is one structure in order (no skipping).

Per line, choose one:

Identifier-only — for named declarations.
Examples: processData, UserService, calculate, __init__.

Header-prefix — for declarations or control-flow blocks.
“Write the beginning of the first line of that node.”
You may omit: modifiers, params, generics, return types, throws, and the opening {/:.

Header-prefix — precise matching rule
We normalize the source header and the provided target line the same way, then do a prefix match.

Normalization pipeline (both sides)
Trim ends; collapse internal whitespace runs to one space.

Strip safe modifiers (per language, whole-word, token boundaries):

TS/JS: export, default, async, declare, abstract, override, public, private, protected, readonly.

Do not strip: static, get, set, * (generator), accessor.

Python: none. (Decorators aren’t on the header line.)

Truncate at the first stop token (if present):

java
Copy
Edit
{  :  ;  =>  =  (  <  throws
(We include ( and < so LLMs can stop before params/generics; throws helps Java/C#.)

Remove trailing line comments (// …, # …) if any.

Minimum-content rule (to avoid over-matching)
Declarations: header-prefix must include at least the kind+name (function processData, class UserService, def expensive_operation), or use Identifier-only.
(Reject function alone.)

Control-flow: must include the keyword + some head (e.g., if (cond, for x in, case 404, except ValueError).
(Reject bare if / else / case alone.)

Ambiguity
If multiple siblings match the normalized prefix, return TARGET_AMBIGUOUS and surface candidates. We never guess. Caller can extend the prefix (e.g., add params) or continue the path deeper.

How to explain it in one sentence (for your docs)
“For each level, write either the identifier name (for declarations) or the beginning of the node’s first line up to any syntax delimiter; you may omit common modifiers. Always list every ancestor.”

Examples (the one you asked about)
Source:

ts
Copy
Edit
export default async function processData(): Promise<Result> {
All valid (same node):

processData (Identifier-only)

function processData (header-prefix; stops before ()

async function processData (modifiers allowed or stripped)

export default async function processData() (stops before : or {)

export default function processData(): (stops at :)

Invalid:

function (fails minimum-content)

---

# Fix

* **Accept** `processData(` and `processData()` as **identifier-only** variants.
  Rationale: our normalization trims at stop tokens (including `(`), so both reduce to `processData`. This matches the “name-only” form we already allow.
* **Still reject** `function` (no name → fails minimum-content for header-prefix).

# Clean rule (tight + LLM-friendly)

* **Identifier-only** (named decls): accept `name`, `name(`, or `name()` → normalize to `name`.
* **Header-prefix** (decls or blocks): must contain **kind + name** for decls (e.g., `function processData`), or **keyword + head** for blocks (e.g., `if (x)`); then we truncate at the first stop token (`{ : ; => = ( < throws`), after stripping safe modifiers.

# Quick sanity for your example

Source:

```ts
export default async function processData(): Promise<Result> {
```

**Valid:**

* `processData` / `processData(` / `processData()`  ← identifier-only
* `function processData`
* `async function processData`
* `export default async function processData()`
* `export default function processData():`

**Invalid:**

* `function`  (no name)
* `process`   (wrong identifier, substrings not allowed)

This keeps the grammar tiny, matches real LLM output, and avoids fuzzy substring matching.


----




pythonif x:
    pass
elif x:  # How to target this?
    pass

make sure we have test cases to distinguish between the entire cascading if block and the child elif block


-----

export default async function processData(int: a, char: 9)<X t: vs*>: Promise<Result> {
