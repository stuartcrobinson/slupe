# Target Matching Specification

## Core Design Decisions

### Target Pattern Types
We support 10 distinct patterns for matching code elements:

```python
class TargetPattern(Enum):
    # Basic
    IDENTIFIER = 1                      # "add"
    KIND_IDENTIFIER = 2                 # "function add" (strips modifiers)
    KIND_IDENTIFIER_W_MODS = 3          # "async function add" (keeps modifiers)
    
    # Extended (with partial params/syntax)
    IDENTIFIER_EXTENDED = 4             # "add(x: number"
    KIND_IDENTIFIER_EXTENDED = 5        # "function add(x: number" (strips)
    KIND_IDENTIFIER_EXTENDED_W_MODS = 6 # "async function add(x: number" (keeps)
    
    # Control flow
    CONTROL_KEYWORD = 7                 # "if"
    CONTROL_HEAD = 8                    # "if x"
    CONTROL_EXTENDED = 9                # "if (x > 0"
    
    # Complete headers
    FULL_HEADER = 10                    # Everything up to {/:
```

### Modifier Handling
- Modifiers are stripped **all or nothing** - no selective stripping
- Patterns without `_W_MODS` suffix strip ALL modifiers
- Patterns with `_W_MODS` suffix keep ALL modifiers

### Language-Specific Definitions

**TypeScript/JavaScript kinds:**
- `function`, `class`, `interface`, `type`, `enum`, `const`, `let`, `var`
- `get`, `set` (treated as kinds, not modifiers)

**TypeScript/JavaScript modifiers (stripped when applicable):**
- `export`, `default`, `async`, `static`, `public`, `private`, `protected`, `readonly`, `abstract`, `declare`, `override`

**Python kinds:**
- `def`, `class`

**Python modifiers:**
- `async` (only modifier that appears on same line as declaration)

### Matching Rules

#### Multiple Matches
- When target matches multiple nodes, return ALL matches
- Let caller handle disambiguation
- Include context to help with disambiguation

#### Identifier Variants
- Accept `name`, `name(`, and `name()` as equivalent for IDENTIFIER pattern
- All normalize to just `name`

#### Control Flow Specifics
- `CONTROL_HEAD` extracts first identifier after keyword
- For `if (x && y)`, `CONTROL_HEAD` matches as `if x`
- `else` has no condition, just matches `else`

#### Extended Patterns
- Match partial text up to any point
- User can stop typing at any character
- Prefix matching on normalized text

### Normalization Pipeline

For structural patterns (non-EXTENDED):
1. Trim whitespace from ends
2. Collapse internal whitespace runs to single space
3. Strip modifiers (if not `_W_MODS` variant)
4. Truncate at first delimiter: `{ : ; => = ( < throws`

For text patterns (EXTENDED):
1. Extract source text from node position
2. Strip modifiers from source if needed (not `_W_MODS`)
3. Normalize whitespace
4. Perform substring/prefix match

### Return Content
- Always return complete node including:
  - Decorators/annotations (even though they're not part of header)
  - JSDoc/docstrings
  - The complete node body

### Ambiguity Handling
- Overloaded functions with same name: return both
- Cross-scope matches (method in class + module function): return both
- Bare keywords that match multiple blocks: return all

## Test Case Requirements

### Basic Function
```typescript
function ProcessData(): void { }
```
- `ProcessData` → matches (IDENTIFIER)
- `function ProcessData` → matches (KIND_IDENTIFIER)
- `ProcessData(` → matches (IDENTIFIER, normalizes to `ProcessData`)

### Decorated/Annotated
```python
@lru_cache
def expensive_operation(n: int) -> int:
    return n
```
- Returns entire decorated function including decorators
- Target `expensive_operation` matches via IDENTIFIER

### Overloaded Functions
```typescript
function add(a: number): number { }
function add(a: number, b: number): number { }
```
- Target `add` returns BOTH functions
- Target `function add(a: number, b: number)` returns only second

### Control Flow
```python
if x > 0:
    print("positive")
elif x < 0:
    print("negative")
else:
    print("zero")
```
- `if` → returns entire if/elif/else block
- `elif` → returns only elif block
- `else` → returns only else block
- `if x` → returns entire if/elif/else block (CONTROL_HEAD)

### Multiple Control Blocks
```python
if x > 0:
    pass
if y > 0:
    pass
```
- Target `if` returns BOTH if statements
- Target `if y` returns only second

### Modifier Handling
```typescript
export async function processData(): void { }
```
- `processData` → matches (IDENTIFIER)
- `function processData` → matches (KIND_IDENTIFIER, strips modifiers)
- `async function processData` → matches (KIND_IDENTIFIER_W_MODS)
- `export async function processData` → matches (KIND_IDENTIFIER_W_MODS or FULL_HEADER)

---

# follow-ups

for whitespace normalization, lets just remove all whitespace complete 

for non-mod cases, we need to get the list of modifiers used in the given code block, according to the treesitter response, and then remove all then from the string header line that we're working on matching. BUT we have to make sure taht we dont accidentally remove the actual identifier (like incase the fx name is "set" but "set" is a valid modifier).  