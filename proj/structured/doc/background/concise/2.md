

the whole point is we need an approach for the LLM to write.  so it has to be super intuitive and obvious.  natural and easy to remmeber and write.  for an LLM. trust your gut, since you are an LLM

---

old ideas, proabbly bad but idk:

Target Syntax: Tree-sitter S-expression queries, simplified:
"(class_definition name:'UserAuth') (method_definition name:'validate')"
"(function_declaration name:'processData')"
"(if_statement condition:'x > 0')"  // first matching if
For markdown: XPath-like but simpler:
"#Installation/#Prerequisites"  // heading path
"#Installation/list[1]/item[2]"  // second item in first list
Boundary Rules:

structure_write(file="auth.py", target="UserAuth.validate", content="def validate(self):...")
structure_replace_text(file="README.md", target="Installation > Prerequisites", old_text="Python 3.8", new_text="Python 3.9")

----

existing:

// File operations
write_file(path, content)
read_file(path)
read_files(paths: string[])
delete_file(path)
move_file(old_path, new_path)
replace_text_in_file(path, old_text, new_text)
replace_all_text_in_file(path, old_text, new_text, count?)
replace_text_range_in_file(path, old_text_beginning, old_text_end, new_text)
append_to_file(path, content)

need new:

// Structure operations
replace_structure(path, target, content)
read_structure(path, target)
read_structures(path, targets: string[])
delete_structure(path, target)
move_structure(path, target, new_path, new_target)
replace_text_in_structure(path, target, old_text, new_text)
replace_all_text_in_structure(path, target, old_text, new_text, count?)
insert_before_structure(path, target, content)
insert_after_structure(path, target, content)


---


now that you have a general idea of what we need, show me some example usages for these new actions we need:


```

// Structure operations
replace_structure(path, target, content)
read_structure(path, target)
read_structures(path, targets: string[])
delete_structure(path, target)
move_structure(path, target, new_path, new_target)
replace_text_in_structure(path, target, old_text, new_text)
replace_all_text_in_structure(path, target, old_text, new_text, count?)
insert_before_structure(path, target, content)
insert_after_structure(path, target, content)
```


using "nesl" syntax:


```

## NESL examples

### example 1

```sh nesl
#!nesl [@three-char-SHA-256: v7r]
action = "write_file"
path = "/absolute/path/to/file.txt"
content = <<'EOT_v7r'

 Multi-line content
 always in a heredoc,

always literal text verbatim

 nothing ever escaped: "'\n

   always with preserved whitespace

   
EOT_v7r
#!end_v7r
```

```json
{
  "action": "write_file",
  "path": "/absolute/path/to/file.txt",
  "content": "\n Multi-line content\n always in a heredoc,\n\nalways literal text verbatim\n\n nothing ever escaped: \"'\\n\n\n   always with preserved whitespace\n\n   \n"
}
```

### example 2

```sh nesl
#!nesl [@three-char-SHA-256: qk6]
action = "replace_text_in_file"
path = "/home/user/config.py"
old_text = <<'EOT_qk6'
  "version": "0.1",
EOT_qk6
new_text = <<'EOT_qk6'
  "version": "0.2",
EOT_qk6
#!end_qk6
```

JSON equivalent:

```json
{
  "action": "replace_text_in_file",
  "path": "/home/user/config.py",
  "old_text": "  \"version\": \"0.1\",",
  "new_text": "  \"version\": \"0.2\",",
}
```
```



## NESL examples for structure operations

### Read a function
```sh nesl
#!nesl [@three-char-SHA-256: rf1]
action = "read_structure"
path = "/app/auth.py"
target = "def validate_user"
#!end_rf1
```

Returns:
```json
{
  "success": true,
  "data": {
    "content": "def validate_user(username, password):\n    if not username or not password:\n        return False\n    user = db.get_user(username)\n    return user and bcrypt.verify(password, user.hash)",
    "line_start": 45,
    "line_end": 49
  }
}
```

### Replace entire method
```sh nesl
#!nesl [@three-char-SHA-256: rs1]
action = "replace_structure"
path = "/app/auth.py"
target = "class UserAuth"
content = <<'EOT_rs1'
class UserAuth:
    """Updated authentication handler."""
    
    def __init__(self, db, cache=None):
        self.db = db
        self.cache = cache or {}
    
    def validate(self, token):
        # New implementation
        return self.cache.get(token) or self._validate_token(token)
EOT_rs1
#!end_rs1
```

### Replace text within specific if-statement
```sh nesl
#!nesl [@three-char-SHA-256: rt1]
action = "replace_text_in_structure"
path = "/app/handlers.py"
target = "if (user.age >= 18 && user.hasPermission('admin'))"
old_text = "console.log"
new_text = "logger.info"
#!end_rt1
```

### Delete a while loop
```sh nesl
#!nesl [@three-char-SHA-256: ds1]
action = "delete_structure"
path = "/app/processor.py"
target = "while (queue.hasNext())"
#!end_ds1
```

### Insert logging before function
```sh nesl
#!nesl [@three-char-SHA-256: ib1]
action = "insert_before_structure"
path = "/app/api.py"
target = "def handle_request"
content = <<'EOT_ib1'
@trace_performance
@require_auth
EOT_ib1
#!end_ib1
```

### Move function to different file
```sh nesl
#!nesl [@three-char-SHA-256: ms1]
action = "move_structure"
path = "/app/utils.py"
target = "def parse_config"
new_path = "/app/config.py"
new_target = "class ConfigParser"  # insert into this class
#!end_ms1
```

### Read multiple structures at once
```sh nesl
#!nesl [@three-char-SHA-256: rm1]
action = "read_structures"
path = "/app/models.py"
targets = <<'EOT_rm1'
class User
def save
def validate
EOT_rm1
#!end_rm1
```

Returns each structure with its location and content.

### Replace all occurrences in a specific function
```sh nesl
#!nesl [@three-char-SHA-256: ra1]
action = "replace_all_text_in_structure"
path = "/app/database.py"
target = "def migrate_schema"
old_text = "conn.execute"
new_text = "await conn.execute"
count = "4"  # optional, verify exactly 4 replacements
#!end_ra1
```

## Key patterns

1. **Target uses first line or signature** - what LLM sees in code
2. **Multi-line content in heredocs** - preserves all formatting
3. **Failures are explicit** - "Found 3 matches for 'def validate'" or "No match found"
4. **Move operations specify container** - where to insert in new file