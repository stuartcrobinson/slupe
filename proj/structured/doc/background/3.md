Yes, flexible matching is feasible and necessary. Tree-sitter gives you the AST nodes - your code decides how to match against user input.

## Matching strategy hierarchy

```javascript
function findStructure(tree, target, language) {
  // Try progressively fuzzier matches
  const matchers = [
    exactSignatureMatch,     // "def validate_user(username, password):"
    partialSignatureMatch,   // "def validate_user"
    identifierOnlyMatch,     // "validate_user"
    fragmentMatch           // "validate"
  ];
  
  for (const matcher of matchers) {
    const nodes = matcher(tree, target, language);
    if (nodes.length === 1) return nodes[0];
    if (nodes.length > 1) {
      throw new Error(`Ambiguous: ${nodes.length} matches for "${target}"`);
    }
  }
  throw new Error(`No match for "${target}"`);
}
```

## Language-specific normalization

```javascript
const LANGUAGE_PATTERNS = {
  python: {
    function: [
      /^def\s+(\w+).*:?$/,  // "def validate_user:" or "def validate_user"
      /^(\w+)$/              // "validate_user"
    ],
    extractName: (input) => {
      const match = input.match(/(?:def\s+)?(\w+)/);
      return match?.[1];
    }
  },
  javascript: {
    function: [
      /^(?:async\s+)?(?:function\s+)?(\w+).*$/,
      /^(\w+)$/
    ],
    extractName: (input) => {
      const match = input.match(/(?:function\s+)?(\w+)/);
      return match?.[1];
    }
  }
};
```

## Critical edge cases

1. **Overloaded names**: 
   - `validate_user` function at module level
   - `validate_user` method in class
   - `validate_user` nested function
   
   Solution: Prefer most visible scope (module > class > nested)

2. **Partial matches**: `"validate"` might match:
   - `validate_user`
   - `validate_input`
   - `validation_helper`
   
   Solution: Exact identifier match only, no substring matching

3. **Syntax variations LLMs produce**:
   ```
   "def validate_user"      // missing colon
   "validate_user()"        // with empty parens  
   "async validate_user"    // JS async
   "validate_user:"         // just identifier + colon
   ```
   
   All should resolve to same function.

## Implementation reality

Tree-sitter query finds ALL functions, then you filter:

```javascript
const query = `
  [(function_definition name: (identifier) @name)
   (method_definition name: (identifier) @name)]
`;

const matches = query.matches(tree.rootNode);
const targetName = extractFunctionName(target, language);

const found = matches.filter(m => 
  m.captures[0].node.text === targetName
);
```

**Bottom line**: Yes, support all three variants. The code complexity is in the matching logic, not tree-sitter. Tree-sitter just gives you nodes - you decide which one matches the user's intent.