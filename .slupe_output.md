=== SLUPE RESULTS ===
p3k âœ… file_read /Users/stuart/repos/slupe/proj/comp/hooks/src/index.ts
=== END ===

=== OUTPUTS ===

[p3k] file_read:
=== START FILE: /Users/stuart/repos/slupe/proj/comp/hooks/src/index.ts ===
import { promisify } from 'util';
import { exec } from 'child_process';
import { interpolateCommand } from './interpolateCommand.js';
import { validateCommand } from './validateCommand.js';
import { formatHookResult } from './formatHookResult.js';
import type { CommandResult } from './types.js';

// Public types
export interface HooksConfig {
  version?: number;
  before?: Command[];
  after?: Command[];
  vars?: Record<string, string>;
}

export interface Command {
  run: string;
  continueOnError?: boolean;
  timeout?: number;
  cwd?: string;
}

export interface HookContext {
  [key: string]: string | number | boolean;
}

export interface HookError {
  command: string;
  error: string;
  stdout?: string;
  stderr?: string;
}

export interface HookResult {
  success: boolean;
  executed: number;
  errors?: HookError[];
}

// Promisified exec
const execAsync = promisify(exec);

// Main class
export class HooksManager {
  private config: HooksConfig;
  private vars: Record<string, string>;
  private repoPath: string;

  constructor(config?: HooksConfig, vars?: Record<string, string>, repoPath?: string) {
    this.config = config || {};
    this.vars = vars || {};
    this.repoPath = repoPath || process.cwd();
  }

  async runBefore(context?: HookContext): Promise<HookResult> {
    const commands = this.config.before || [];
    return this.runCommands(commands, context);
  }

  async runAfter(context?: HookContext): Promise<HookResult> {
    const commands = this.config.after || [];
    return this.runCommands(commands, context);
  }



  private async runCommands(commands: Command[], context?: HookContext): Promise<HookResult> {
    const results: CommandResult[] = [];

    for (const cmd of commands) {
      try {
        // Interpolate variables
        const interpolatedCmd = interpolateCommand(cmd, this.vars, context);

        // Validate command
        const validation = validateCommand(interpolatedCmd);
        if (!validation.valid) {
          const result: CommandResult = {
            command: cmd.run,
            success: false,
            error: validation.error || 'Invalid command'
          };
          results.push(result);

          if (!cmd.continueOnError) {
            break;
          }
          continue;
        }

        // Execute command
        const result = await this.executeCommand(interpolatedCmd);

        results.push({
          command: cmd.run,
          ...result
        });

        if (!result.success && !cmd.continueOnError) {
          break;
        }
      } catch (error: any) {
        const result: CommandResult = {
          command: cmd.run,
          success: false,
          error: error.message
        };
        results.push(result);

        if (!cmd.continueOnError) {
          break;
        }
      }
    }

    return formatHookResult(results);
  }

  private async executeCommand(cmd: Command): Promise<Omit<CommandResult, 'command'>> {
    const timeout = cmd.timeout || 30000;
    const options = {
      cwd: cmd.cwd || this.repoPath,
      timeout,
      encoding: 'utf8' as const,
      shell: true as any  // Ensure shell interpretation for redirects
    };

    try {
      const { stdout, stderr } = await execAsync(cmd.run, options);
      return {
        success: true,
        stdout: stdout || '',
        stderr: stderr || ''
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        stdout: error.stdout || '',
        stderr: error.stderr || ''
      };
    }
  }
}
=== END FILE: /Users/stuart/repos/slupe/proj/comp/hooks/src/index.ts ===
=== END ===